#!/usr/bin/env python3
import argparse, sqlite3, sys, json, os
from datetime import datetime, timezone
import xml.etree.ElementTree as ET

# Normalize ESPN sport labels -> nicer XMLTV categories
SPORT_MAP = {
    'Motor Sports': 'Motorsports',
    'Action Sports': 'Action sports',
    'Field Hockey': 'Field hockey',
    'Water Polo': 'Water polo',
}
def _norm_sport(x: str) -> str:
    if not x:
        return ''
    x = x.strip()
    return SPORT_MAP.get(x, x)


# Placeholder wording (can be overridden by env vars)
PH_TITLE    = os.getenv('VC_PLACEHOLDER_TITLE', 'Stand By')
PH_SUBTITLE = os.getenv('VC_PLACEHOLDER_SUBTITLE', '')
PH_SUMMARY  = os.getenv('VC_PLACEHOLDER_SUMMARY', 'No live event scheduled')

LAN_ORIGIN = "http://192.168.86.72:8094"


def iso_to_xmltv(ts: str) -> str:
    dt = datetime.fromisoformat(ts.replace("Z","+00:00")).astimezone(timezone.utc)
    return dt.strftime("%Y%m%d%H%M%S +0000")

def conn_open(path):
    c = sqlite3.connect(path); c.row_factory = sqlite3.Row; return c

def have_table(conn, name: str) -> bool:
    return bool(conn.execute("SELECT 1 FROM sqlite_master WHERE type='table' AND name=?", (name,)).fetchone())

def cols(conn, name: str) -> set:
    try:
        return {r["name"] for r in conn.execute(f"PRAGMA table_info({name})").fetchall()}
    except sqlite3.OperationalError:
        return set()

def latest_plan_id(conn):
    r = conn.execute("SELECT MAX(plan_id) AS pid FROM plan_slot").fetchone()
    return int(r["pid"]) if r and r["pid"] is not None else None

def compute_window(conn, pid: int) -> tuple[str|None, str|None]:
    r = conn.execute(
        "SELECT MIN(start_utc) AS vfrom, MAX(end_utc) AS vto FROM plan_slot WHERE plan_id=?",
        (pid,)
    ).fetchone()
    return (r["vfrom"], r["vto"]) if r else (None, None)

def read_checksum(conn, pid: int) -> str|None:
    # Prefer plan_run.checksum if present
    if have_table(conn, "plan_run"):
        c = cols(conn, "plan_run")
        if "checksum" in c:
            r = conn.execute("SELECT checksum FROM plan_run WHERE id=?", (pid,)).fetchone()
            if r: return r["checksum"]
    # Fallback to plan_meta.checksum(plan_id) if present
    if have_table(conn, "plan_meta"):
        c = cols(conn, "plan_meta")
        key = "plan_id" if "plan_id" in c else ("id" if "id" in c else None)
        if key and "checksum" in c:
            r = conn.execute(f"SELECT checksum FROM plan_meta WHERE {key}=?", (pid,)).fetchone()
            if r: return r["checksum"]
    return None

def load_channels(conn):
    return conn.execute(
        "SELECT id, chno, name FROM channel WHERE active=1 ORDER BY chno ASC"
    ).fetchall()

def load_slots(conn, pid):
    q = """
    SELECT
      s.channel_id AS chan,
      s.start_utc  AS slot_start,
      s.end_utc    AS slot_stop,
      s.event_id   AS event_id,
      e.title      AS event_title,
      e.subtitle   AS event_subtitle,
      e.summary    AS event_summary,
      e.sport      AS event_sport,
      e.image      AS event_image
    FROM plan_slot s
    LEFT JOIN events e ON e.id = s.event_id
    WHERE s.plan_id = ?
    ORDER BY s.channel_id, s.start_utc
    """
    return conn.execute(q,(pid,)).fetchall()

def build_xml(ch_rows, slots, resolver_base, meta):
    tv = ET.Element("tv", {"generator-info-name":"espn-clean-v2.0"})
    tv.append(ET.Comment(
        f" plan_id={meta.get('id')} valid_from={meta.get('valid_from')} "
        f"valid_to={meta.get('valid_to')} checksum={meta.get('checksum')} "
    ))
    # channels
    for ch in ch_rows:
        c = ET.SubElement(tv, "channel", id=ch["id"])
        ET.SubElement(c, "display-name").text = ch["name"]
        ET.SubElement(c, "lcn").text = str(ch["chno"])
    # programmes
    programmes = 0
    for r in slots:
        chan  = r["chan"]
        start = iso_to_xmltv(r["slot_start"])
        stop  = iso_to_xmltv(r["slot_stop"])
        p = ET.SubElement(tv, "programme", channel=chan, start=start, stop=stop)
        ET.SubElement(p, "title").text = (   (r["event_title"].strip() if ("event_title" in r.keys() and r["event_title"]) else "")    or PH_TITLE)
        if r["event_subtitle"]: ET.SubElement(p, "sub-title").text = r["event_subtitle"]
        if r["event_summary"]:  ET.SubElement(p, "desc").text = r["event_summary"]
        ET.SubElement(p, "category").text = "Sports"
        if ("event_id" in r.keys()) and r["event_id"] and ("event_sport" in r.keys()) and r["event_sport"]:
            ET.SubElement(p, "category").text = _norm_sport(r["event_sport"])
        if r["event_image"]:    ET.SubElement(p, "icon", src=r["event_image"])
        ET.SubElement(p, "url").text = f"{resolver_base}/vc/{chan}"
        programmes += 1
    # pretty
    def indent(e, level=0):
        i = "\n" + level*"  "
        if len(e):
            if not e.text or not e.text.strip(): e.text = i + "  "
            for child in e: indent(child, level+1)
            if not child.tail or not child.tail.strip(): child.tail = i
        if level and (not e.tail or not e.tail.strip()): e.tail = i
    indent(tv)
    return ET.ElementTree(tv), programmes

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--db", required=True)
    ap.add_argument("--out", required=True)
    ap.add_argument("--resolver-base", default=LAN_ORIGIN)
    args = ap.parse_args()

    conn = conn_open(args.db)
    pid = latest_plan_id(conn)
    if pid is None:
        print(json.dumps({"ts": datetime.now(timezone.utc).isoformat(),
                          "mod":"xmltv_from_plan","event":"no_active_plan"}))
        sys.exit(0)

    vfrom, vto = compute_window(conn, pid)
    checksum = read_checksum(conn, pid)
    meta = {"id": pid, "valid_from": vfrom, "valid_to": vto, "checksum": checksum}

    channels = load_channels(conn)
    slots    = load_slots(conn, pid)
    tree, n  = build_xml(channels, slots, args.resolver_base, meta)
    tree.write(args.out, encoding="utf-8", xml_declaration=True)
    print(json.dumps({
        "ts": datetime.now(timezone.utc).isoformat(),
        "mod":"xmltv_from_plan","event":"xmltv_written",
        "plan_id": pid, "out": args.out, "channels": len(channels), "programmes": n
    }))

if __name__ == "__main__":
    main()
