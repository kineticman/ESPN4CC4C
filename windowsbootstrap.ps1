<#   windowsbootstrap.ps1 â€” ESPN4CC4C one-shot bootstrap for Windows  Usage (PowerShell):    .\windowsbootstrap.ps1 -LanIp 192.168.88.240 [-Port 8094] [-CCPort 8089] [-Days 3] [-ValidHours 72] [-MinGapMins 30]  Notes:    - Runs docker compose from the script folder.    - GET-only health and sanity checks (no HEAD).    - Writes .env in UTF-8 (no BOM).#>param(  [Parameter(Mandatory=$true)] [string]$LanIp,  [int]$Port = 8094,  [int]$CCPort = 8089,  [int]$Days = 3,  [int]$ValidHours = 72,  [int]$MinGapMins = 30)Set-StrictMode -Version Latest$ErrorActionPreference = 'Stop'# --- helpers ---function Write-Info($msg){ Write-Host "[INFO] $msg" -ForegroundColor Cyan }function Write-Ok  ($msg){ Write-Host "[ OK ] $msg" -ForegroundColor Green }function Write-Err ($msg){ Write-Host "[ERR ] $msg" -ForegroundColor Red }function Assert-Command($name){  if (-not (Get-Command $name -ErrorAction SilentlyContinue)) {    Write-Err "Required command '$name' not found in PATH."    exit 1  }}function Write-FileUtf8NoBom($Path, $Content){  $dir = Split-Path -Parent $Path  if ($dir -and -not (Test-Path $dir)){ New-Item -ItemType Directory -Force -Path $dir | Out-Null }  $utf8NoBom = New-Object System.Text.UTF8Encoding($false)  [System.IO.File]::WriteAllText($Path, $Content, $utf8NoBom)}# --- paths anchored to script dir ---$Root   = $PSScriptRootif (-not $Root) { $Root = (Get-Location).Path } # fallback for ISESet-Location $Root$EnvPath   = Join-Path $Root '.env'$DataDir   = Join-Path $Root 'data'$LogsDir   = Join-Path $Root 'logs'$OutDir    = Join-Path $Root 'out'$EntryPath = Join-Path $Root 'docker-entrypoint.sh'$ComposeYml = Join-Path $Root 'docker-compose.yml'$Dockerfile = Join-Path $Root 'Dockerfile'# --- preflight ---Assert-Command 'docker'Assert-Command 'docker-compose'  # some setups still alias; harmless if missingAssert-Command 'docker'          # ensure docker itself existstry { docker compose version | Out-Null } catch { Write-Err "Docker Compose V2 not available. Update Docker Desktop."; exit 1 }if (-not (Test-Path $ComposeYml)) { Write-Err "docker-compose.yml not found at $ComposeYml"; exit 1 }if (-not (Test-Path $Dockerfile)) { Write-Err "Dockerfile not found at $Dockerfile"; exit 1 }if (-not (Test-Path $EntryPath)) { Write-Err "docker-entrypoint.sh not found at $EntryPath (did the cleanup move/delete it?)"; exit 1 }# --- ensure runtime dirs ---foreach($p in @($DataDir,$LogsDir,$OutDir)){  if (-not (Test-Path $p)){ New-Item -ItemType Directory -Force -Path $p | Out-Null }}Write-Ok "Ensured ./data ./logs ./out"# --- .env handling (do not print key) ---$envTemplate = @"# ESPN4CC4C .env# NOTE: Do not commit secrets. This file is written in UTF-8 (no BOM).LAN_IP=$LanIpPORT=$PortCC_HOST=$LanIpCC_PORT=$CCPort# WATCH_API_KEY=<put-your-key-here>"@if (-not (Test-Path $EnvPath)) {  Write-FileUtf8NoBom -Path $EnvPath -Content $envTemplate  Write-Ok ".env written (LF, no BOM)"} else {  # Merge/update core keys but preserve existing WATCH_API_KEY if present  $current = Get-Content -Raw -Encoding UTF8 $EnvPath  $map = @{}  foreach($line in ($current -split "`r?`n")){    if ($line -match '^\s*#') { continue }    if ($line -match '^\s*$') { continue }    $kv = $line -split '=',2    if ($kv.Count -eq 2){ $map[$kv[0]] = $kv[1] }  }  $map['LAN_IP']  = $LanIp  $map['PORT']    = "$Port"  $map['CC_HOST'] = $LanIp  $map['CC_PORT'] = "$CCPort"  # WATCH_API_KEY stays as-is if already present  $lines = @("# ESPN4CC4C .env","# (existing values preserved where possible)") + ($map.GetEnumerator() | ForEach-Object { "$($_.Key)=$($_.Value)" })  $out = ($lines -join "`n") + "`n"  Write-FileUtf8NoBom -Path $EnvPath -Content $out  Write-Ok ".env updated (LF, no BOM)"}# --- build & up ---Write-Info "Starting container..."try {  docker compose down --remove-orphans | Out-Null  docker builder prune -f | Out-Null  docker compose build --no-cache  docker compose up -d} catch {  Write-Err "docker compose up failed: $($_.Exception.Message)"  exit 1}# --- wait for /health ---$healthUrl = "http://$LanIp`:$Port/health"$deadline = (Get-Date).AddMinutes(2)$healthy = $falseWrite-Info "Waiting for resolver health at $healthUrl ..."while((Get-Date) -lt $deadline){  try {    $r = Invoke-WebRequest -Uri $healthUrl -UseBasicParsing -TimeoutSec 5    if ($r.StatusCode -eq 200 -and ($r.Content -match '"ok"\s*:\s*true')){      $healthy = $true; break    }  } catch { Start-Sleep -Milliseconds 800 }  Start-Sleep -Milliseconds 800}if (-not $healthy){ Write-Err "Resolver did not become healthy at $healthUrl"; exit 1 }Write-Ok "Resolver healthy"# --- run pipeline inside container ---function DcExec($cmd){  docker compose exec -T espn4cc sh -lc $cmd}Write-Info "DB migrate..."DcExec "python3 /app/bin/db_migrate.py --db /app/data/eplus_vc.sqlite3" | Write-HostWrite-Info "Ingest watch graph (Days=$Days)..."$ingOut = DcExec "python3 /app/bin/ingest_watch_graph_all_to_db.py --db /app/data/eplus_vc.sqlite3 --days $Days"$ingOut | Write-Hostif (-not ($ingOut -match 'events_ingested|ingested')) {  Write-Err "Ingest did not report counts - check WATCH_API_KEY and network."  exit 1}Write-Info "Build plan (ValidHours=$ValidHours, MinGapMins=$MinGapMins)..."DcExec "python3 /app/bin/build_plan.py --db /app/data/eplus_vc.sqlite3 --valid-hours $ValidHours --min-gap-mins $MinGapMins --align 30" | Write-HostWrite-Info "Generate XMLTV..."DcExec "python3 /app/bin/xmltv_from_plan.py --db /app/data/eplus_vc.sqlite3 --out /app/out/epg.xml" | Write-HostWrite-Info "Generate M3U..."DcExec "python3 /app/bin/m3u_from_plan.py --db /app/data/eplus_vc.sqlite3 --out /app/out/playlist.m3u --resolver-base http://$LanIp`:$Port --cc-host $LanIp --cc-port $CCPort" | Write-Host# --- sanity checks (GET only) ---$xmlUrl = "http://$LanIp`:$Port/out/epg.xml"$m3uUrl = "http://$LanIp`:$Port/playlist.m3u"try {  $xml = Invoke-WebRequest $xmlUrl -UseBasicParsing -TimeoutSec 10  $progCount = ([regex]::Matches($xml.Content,'<programme\b')).Count  Write-Host ("{0} programmes found" -f $progCount) -ForegroundColor Green} catch { Write-Err "Could not GET epg.xml at $xmlUrl" }try {  $m3u = Invoke-WebRequest $m3uUrl -UseBasicParsing -TimeoutSec 10  $lines = ($m3u.Content -split "`r?`n" | Select-Object -First 5) -join "`n"  Write-Info "playlist.m3u (first 5 lines):"  Write-Host $lines} catch { Write-Err "Could not GET playlist.m3u at $m3uUrl" }Write-Host "========================================" -ForegroundColor DarkCyanWrite-Host ("XMLTV    : {0}" -f $xmlUrl)Write-Host ("M3U      : {0}" -f $m3uUrl)Write-Host ("Health   : {0}" -f $healthUrl)Write-Host "========================================" -ForegroundColor DarkCyanWrite-Ok "Bootstrap complete."